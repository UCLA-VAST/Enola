from animation import CodeGen, set_hardware_paramters
import argparse
import json

class Simulator():
    """calculate circuit fidelity based on code_full files."""

    def __init__(self,
                 code_file_name: str,
                 param_fidelity: dict,
                 ):
        """
        Args:
            code_file_name (str): file name of code_full generated by CodeGen.
            param_fidelity (dict): fideilty operations
        """
        # define fidelity parameter
        self.fidelity_2q_gate = 0.995
        self.fidelity_1q_gate = 0.995
        self.fidelity_atom_transfer = 0.999
        self.coherence_time = 1.5e6 # ms
        if "2QG" in param_fidelity:
            self.fidelity_2q_gate = param_fidelity["2QG"]
        self.fidelity_2q_gate_for_idle = 1 - (1-self.fidelity_2q_gate)/2
        if "1QG" in param_fidelity:
            self.fidelity_1q_gate = param_fidelity["1QG"]
        if "AT" in param_fidelity:
            self.fidelity_atom_transfer = param_fidelity["AT"]
        if "T" in param_fidelity:
            self.coherence_time = param_fidelity["T"]
        
        self.n_qubit = 0
        self.list_instrcution = []
        self.parse(code_file_name)

        # data members for fidelity computation
        self.cir_fidelity = 1
        self.cir_fidelity_2q_gate = 1
        self.cir_fidelity_2q_gate_for_idle = 1
        self.cir_fidelity_1q_gate = 1
        self.cir_fidelity_atom_transfer = 1
        self.cir_fidelity_coherence = 1
        self.cir_qubit_idle_time = []
        
    def parse(self, code_file: str):
        with open(code_file, 'r') as f:
            self.list_instrcution = json.load(f)
        self.n_qubit = self.list_instrcution[0]['n_q']

    def simulate(self):
        self.cir_fidelity = 1
        self.cir_fidelity_2q_gate = 1
        self.cir_fidelity_2q_gate_for_idle = 1
        self.cir_fidelity_1q_gate = 1
        self.cir_fidelity_atom_transfer = 1
        self.cir_fidelity_coherence = 1
        self.cir_qubit_idle_time = [0 for i in range(self.n_qubit)]
        num_movement_stage = 0
        list_movement_duration = []
        list_atom_transfer_duration = []
        for instruction in self.list_instrcution:
            duration = instruction["duration"]
            if instruction["type"] == "Init":
                continue
            elif instruction["type"] == "Rydberg":
                list_gates = instruction["gates"]
                list_active_qubit = [False for i in range(self.n_qubit)]
                if len(list_gates) == 0:
                    continue
                for gate in list_gates:
                    list_active_qubit[gate["q0"]] = True
                    list_active_qubit[gate["q1"]] = True
                # calculate the fidelity of two-qubit gates
                self.cir_fidelity_2q_gate *= pow(self.fidelity_2q_gate, len(list_gates))
                # calculate the fidelity of idle qubits affected by Rydberg laser
                self.cir_fidelity_2q_gate_for_idle *= pow(self.fidelity_2q_gate_for_idle, self.n_qubit - 2*len(list_gates))
                # for i in range(self.n_qubit):
                #     if not list_active_qubit[i]:
                #         self.cir_qubit_idle_time[i] += duration
            elif instruction["type"] == "Activate" or instruction["type"] == "Deactivate":
                key = ""
                if instruction["type"] == "Activate":
                    key = "pickup_qs"
                else:
                    key = "dropoff_qs"
                list_qubits = instruction[key]
                list_active_qubit = [False for i in range(self.n_qubit)]
                for qubit in list_qubits:
                    list_active_qubit[qubit] = True
                # calculate the fidelity of atom transfer
                self.cir_fidelity_atom_transfer *= pow(self.fidelity_atom_transfer, len(list_qubits))
                for i in range(self.n_qubit):
                    if not list_active_qubit[i]:
                        self.cir_qubit_idle_time[i] += duration
            elif instruction["type"] == "Move":
                if duration > 1e-4:
                    for i in range(self.n_qubit):
                        self.cir_qubit_idle_time[i] += duration
                    num_movement_stage += 1
                    list_movement_duration.append(duration)
            else:
                raise ValueError("Wrong instruction type")
            # print("after {}, the fidelity is:".format(instruction["type"]))
            # print("                          cir_fidelity_2q_gate = {:10.04f},".format(self.cir_fidelity_2q_gate))
            # print("                          cir_fidelity_2q_gate_for_idle = {:10.04f},".format(self.cir_fidelity_2q_gate_for_idle))
            # print("                          cir_fidelity_atom_transfer = {:10.04f}".format(self.cir_fidelity_atom_transfer))
            # print("                          cir_qubit_idle_time = {}".format(self.cir_qubit_idle_time))
            # input()
        # print(self.coherence_time)
        for t in self.cir_qubit_idle_time:
            self.cir_fidelity_coherence *= (1 - t/self.coherence_time)
        self.cir_fidelity = self.cir_fidelity_1q_gate * self.cir_fidelity_2q_gate * self.cir_fidelity_2q_gate_for_idle \
                            * self.cir_fidelity_atom_transfer * self.cir_fidelity_coherence
        total_movement_time = sum(list_movement_duration)
        results = { "cir_fidelity" : self.cir_fidelity,
                    "cir_fidelity_1q_gate": self.cir_fidelity_1q_gate,
                    "cir_fidelity_2q_gate": self.cir_fidelity_2q_gate,
                    "cir_fidelity_2q_gate_for_idle": self.cir_fidelity_2q_gate_for_idle,
                    "cir_fidelity_atom_transfer": self.cir_fidelity_atom_transfer,
                    "cir_fidelity_coherence": self.cir_fidelity_coherence,
                    "num_movement_stage": num_movement_stage,
                    "movement_time_ratio": [ total_movement_time/self.cir_qubit_idle_time[i] for i in range(self.n_qubit) ],
                    "average_movement": sum(list_movement_duration) / len(list_movement_duration) ,
                    "list_movement_duration": list_movement_duration}
        return results
        
if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument('input_file', type=str)
    parser.add_argument('--codeGen', help='require codeGen', action='store_true', default=False)
    parser.add_argument('--arch_param', help='hardware parameters for Enola', type=str, default = "hardware_spec/compute_store_arch.json")
    parser.add_argument('--fidelity_param', help='hardware fidelity for Enola', type=str, default = "hardware_spec/compute_store_arch_fidelity.json")
    args = parser.parse_args()

    with open(args.input_file, 'r') as f:
        data = json.load(f)
    
    with open(args.arch_param, 'r') as f:
        param = json.load(f)
        set_hardware_paramters(param)

    file_name = args.input_file
    if args.codeGen:
        codegen = CodeGen(
            args.input_file,
            no_transfer=False,
            dir='./results/fidelity/'
        )
        file_name = codegen.code_full_file

    with open(args.fidelity_param, 'r') as f:
        param_fidelity = json.load(f)

    simulator = Simulator(file_name, param_fidelity)
    fideilty_result = simulator.simulate()
    directory = './results/fidelity/'
    filename = directory + \
            (args.input_file.split('/')[-1]).replace('.json', '_fidelity.json')
    with open(filename, 'w') as f:  
        json.dump(fideilty_result, f, indent = 2)